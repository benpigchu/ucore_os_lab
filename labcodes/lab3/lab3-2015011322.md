# Lab3 报告

## 练习1：给未被映射的地址映射上物理页

如同注释中已有的步骤，我们先调用 lab2 中的 `get_pte` 找到页表项，若没有映射就分配一个物理页并建立映射。

以下是问题的回答：

### 1.1 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对 ucore 实现页替换算法的潜在用处。

它们的组成部分已经在 lab2 的报告中说明。显然页是否存在这一位一定会被用到。其中对于实现页替换算法特别有用的是是否已被访问过，是否被写过这两个由 CPU 自动设置的位，可用于用于统计内存使用频率，并以此为依据选择被替换的页。

### 1.2 如果 ucore 的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

和一般的页访问异常处理一致，lab2 的报告中有描述。

然而有一个例外：如果跳转到中断处理例程时发生缺页，会触发 Double Fault。我们的实现不应该让这种情况出现。

## 练习2：补充完成基于FIFO的页面替换算法

如同注释中已有的步骤，我们在 `swap_fifo.c` 两个函数中分别向链表加入新页和取出旧页，并在 `do_pgfault` 函数中，通过页表项判断是否是已换出的页，如果是再重新换入，重写页表项。

以下是问题的回答：

### 2.1 如果要在 ucore 上实现"extended clock 页替换算法"请给你的设计方案，现有的 swap_manager 框架是否足以支持在 ucore 中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基于此扩展的设计方案。

现有的框架是足以实现 extended clock 页替换算法的。我们直接利用页表项中的链表实现环形列表，每当要进入下一个页时将链表首项移到链表尾部，同时由于页表项中有相应的读写位，我们直接读取修改页对应的页表项中的位即可。注意修改页表项后，TLB 中的缓存也需要刷新。

### 2.2 需要被换出的页的特征是什么？

第一个写入位和访问位均为 0 的页。注意在经过写入位或访问位非 0 的页时，对应位会被修改（其中一位改为 0，优先改访问位），所以一定会有页被选中。

### 2.3 在ucore中如何判断具有这样特征的页？

读写页对应的页表项。

### 2.4 何时进行换入和换出操作？

在缺页时换入，内存不够时换出。