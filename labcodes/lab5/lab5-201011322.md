# Lab5 报告

## 知识点

进程的加载、等待、结束。用户进程的处理。

另外还涉及了 ELF 文件的格式。在挑战中还有写时复制技术的实现。

没有涉及挂起的进程。

## 练习 0

注意这里需要修改少许代码。
- `alloc_proc` 函数中需要对新增的字段初始化，但是由于使用 `memset` 并不需要修改。
- `do_fork` 函数中将进程插入进程链表、增加进程计数器的操作使用新的 `set_links` 实现。注意这个操作还会设置进程间关系。之前我们已经设置了父进程，这里改变一下代码的顺序。
- `idt_init` 函数中我们在系统调用触发后不自动关闭中断。
- 在时钟中断中设置 `need_resched` 提示调度器可以调度。原有的打印操作可以移除。

## 练习 1：加载应用程序并执行

原有的注释十分详细，所以我们直接按照注释，把代码段和数据段设置为用户的相应段，然后把 `esp` 设置为用户的栈顶，把 `eip` 设为程序的入口即可。这里和参考答案是一致的。

以下为问题的回答：

### 1.1 当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。

进程创建并加载后进入 `PROC_RUNNABLE` 状态。之后调度器选择该进程时，通过 `proc_run` 函数进行切换，其作用已经在 lab4 中解释，但是注意到在 `copy_thread` 中，新的进程的 `eip` 被设置为 `forkret` 函数的地址，于是 `proc_run` 中的 `switch_to` 调用后会跳到 `forkret` 函数，之后会跳到中断返回程序 `__trapret`，再之后会根据 `trapframe` 恢复上下文，并通过中断返回 `iret` 指令进入用户态开始执行用户进程。`iret` 的具体作用在 lab1 的报告中已经解释过了，于是由于 `load_icode` 中我们填写的代码的设置，`iret` 指令执行后是可以直接跳到用户进程的。

## 练习 2：父进程复制自己的内存空间给子进程

注释完整地描述了要填写的代码，只需复制页的内容并将新的对应关系插入页表即可。这里和参考答案是一致的。

以下为问题的回答：

### 2.1 如何设计实现“Copy on Write 机制”

我们在 fork 时只复制页表，同时将两个进程页表中的页设为不可写（此时要刷新TLB）。之后在发生缺页异常时，判断是否是写了本应该可写却由于 Copy on Write 机制不可写的页，如果是，则复制该页，修改页表（此时要刷新TLB），返回。注意每个页都有一个引用计数标记，表示有多少进程使用该页，复制时应该对应地修改引用计数标记（加一），同时写时复制时也应该修改引用计数标记（减一），而当一个本应该可写的页却由于 Copy on Write 机制不可写的引用计数变为一时，也应该修改页表（此时要刷新TLB）将其设为可写，因为它不会再被复制了。

这样便大致实现了 Copy on Write 机制

## 练习 3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

系统调用是通过 `int 0x80` 中断的处理程序实现的，根据各寄存器的内容确定系统调用的类型和参数。

fork 是在 `do_fork` 中实现的，它创建了一个新的进程控制块（处于 `PROC_UNINIT` 状态），并将原进程的信息复制到新的进程控制块，复制内存，设定父进程和新的内核栈，同时修改 `eax` 寄存器设定返回值，之后使其可以运行（处于 `PROC_RUNNABLE` 状态）。

exec 是在 `do_execve` 中实现的，它清除了当前进程的内存布局，然后调用 `load_icode` 加载新的 ELF 文件，同时设定新的内存布局。不改变进程状态。

wait 是在 `do_wait` 中实现的，它会在当前进程的子进程中查找相应的进程（如果没有就返回错误），若找到的子进程已经即将结束（处于 `PROC_ZOMBIE` 状态），则释放其资源直接返回，否则将当前进程设为睡眠（处于 `PROC_SLEEPING` 状态），同时进行调度，直到子进程即将结束时再调度回来继续。

kill 是在 `do_kill` 中实现的，它会将相应进程设置为 `PF_EXITING`，这样在下次该进程内中断时进程会自己退出。另外如果该进程正在等待其他进程，它也会在被调度时自己退出。不改变进程状态。

exit 是在 `do_exit` 中实现的，它会释放自己的大部分资源，并把自己设为即将结束（处于 `PROC_ZOMBIE` 状态），之后如有正在等待的父进程就唤醒父进程（调用 `wakeup_proc` 使其进入 `PROC_RUNNABLE` 状态）。

以下为问题的回答：

### 3.1 请分析 fork/exec/wait/exit 在实现中是如何影响进程的执行状态的？

上面的解释已包含相关内容

### 3.2 请给出ucore中一个用户态进程的执行状态生命周期图。

以下图直接来源于原有的注释

```
 alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  +
                                           -----------------------wakeup_proc----------------------------------
```

注意图中的 `try_free_pages` 本实验尚未涉及；`wakeup_proc` 会在进程创建、子进程退出、定时器超时等情况调用；`PROC_ZOMBIE` 状态的进程会在父进程退出或使用 `wait` 之后正式消失。

