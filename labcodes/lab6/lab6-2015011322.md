# Lab6 报告

## 知识点

时间片轮转算法、调度器框架，另外还涉及了 Stride Scheduling 调度算法。

没有涉及多种其他调度算法、实时调度、多处理器调度、优先级反置问题的处理。

## 练习 0

`proc_struct` 中又有新字段了，`run_link` 字段需要特殊的初始化。由于在本实验中，每个 tick 都可能需要执行调度，故时钟中断处理也需要修改，改为直接调用 `sched_class_proc_tick` 函数。

## 练习1：使用 Round Robin 调度算法

### 1.1 请理解并分析 `sched_calss` 中各个函数指针的用法，并接合 Round Robin 调度算法描述 ucore 的调度执行过程

`init` 初始化了数据结构，包括一个进程数量计数器和一个链表。

`enqueue` 将进程加入链表（从尾部），进程数量计数器加一。本算法中顺便设置了进程的时间片计数。

`dequeue` 将进程移出链表，进程数量计数器减一。

`pick_next` 选择一个新的进程运行。本算法中取链表头部进程。

`proc_tick` 时钟中断时进行更新。本算法中自减当前进程的时间片计数，并在时间计数为 0 时设为可调度即可。

ucore 会把可运行状态的进程通过 `enqueue` 加入链表，之后当需要调度时将当前进程 `enqueue` 加入链表之后通过 `pick_next` 获取下一个要运行的进程进程并 `dequeue` 取出它（如果没有就使用 `idle` 进程）然后调度到该进程。注意在时钟中断时，会调用 `proc_tick` 更新当前进程时间片信息，之后若当前进程可调度，会触发调度。

### 1.2 请在实验报告中简要说明如何设计实现“多级反馈队列调度算法”

我们需要维护多个优先级各自的队列。

`proc_tick` 函数和上面一样无需修改。

`init` 函数初始化了数据结构。

`enqueue` 将进程加入对应优先级的链表。在这之前，如果是还未用完时间片的进程，降低一级优先级。顺便设置进程的时间片计数。

`dequeue` 将进程移出所在的链表。

`pick_next` 选择优先级，并从对应优先级的链表中取出一个进程返回。

## 练习2：实现 Stride Scheduling 调度算法

原有的注释详细得过分了，只看注释就够写代码了。我是基于新提供的斜堆实现的，参考答案还实现了基于链表的版本。

`proc_tick` 函数和上面一样无需修改。

`init` 函数初始化了斜堆。

`enqueue` 将进程加入斜堆。顺便设置进程的时间片计数。

`dequeue` 将进程移出斜堆。

`pick_next` 返回斜堆顶部进程，并更新其 `stride` 值（加上 `BIG_STRIDE` 除以 `prior`）。因为此时选择的进程必然会被取出执行，所以在此时更新。

注意由于我们总是将 `stride` 值最小的进程的值加上一个不大于 `BIG_STRIDE` 的值，所以如果不考虑整数的溢出，在任何时刻 `stride` 值最大的进程与 `stride` 值最小的进程的 `stride` 值之差必然不大于 `BIG_STRIDE` 的值，否则若这种情况出现，那么在 `stride` 值最大的进程的 `stride` 值上一次更新之前它必然 `stride` 值不大于现在的 `stride` 值最小的进程的 `stride` 值，否则它在上一次更新之前就不是 `stride` 值最小的进程了（现在 `stride` 值最小的进程当时 `stride` 值更小，因为 `stride` 值不会减少）。但是这样的话，`stride` 值最大的进程的 `stride` 值上一次更新时增加的值便大于 `BIG_STRIDE` 的值，矛盾。于是在任何时刻 `stride` 值最大的进程与 `stride` 值最小的进程的 `stride` 值之差必然不大于 `BIG_STRIDE` 的值。现在我们考虑整数溢出，由于我们采取相减看符号的方式比较整数，所以只有相差不超过 `0x7FFFFFFF` 时才能保证比较结果正确。另一方面，`BIG_STRIDE` 的值越大，除法误差越小，于是我们应当将 `BIG_STRIDE` 设为 `0x7FFFFFFF`。