# Lab4 报告

## 知识点

进程的创建、切换。进程控制块与上下文。

进程程序的加载、等待、退出等要等到 lab5 才会涉及。

没有涉及到挂起的进程。

## 练习 1：分配并初始化一个进程控制块

尽管注释中给出了需要初始化的字段，但是并没有给出初始化的值。实际上只需要将 `state` 字段设为 `PROC_UNINIT`，`cr3` 字段设为系统的页表位置 `boot_cr3`，`pid` 设为无效的值 -1 ，其余字段填 0 即可。

和标准答案相比，采取了先填 0 后设置特殊字段的方式，代码更加简洁。

下面是问题的回答：

### 1.1 请说明 `proc_struct` 中 `struct context context` 和 `struct trapframe *tf` 成员变量含义和在本实验中的作用

`struct context context` 字段存储了进程的上下文（寄存器信息），用于恢复与保存寄存器。

`struct trapframe *tf` 字段存储了进程被打断时的中断信息。注意其中有进程所使用的段，由此可判断是内核态进程还是用户态进程。

练习 3 中会有更详细的描述。

## 练习 2：为新创建的内核线程分配资源

原有的注释已经足够详细。但是除了注释有的内容， `pid` `parent` 两个字段也应当正确设置。

注意标准答案通过关中段保护了一些全局共享变量。由于未被告知此时可能有中断，没有意识到这个问题。我在代码中补上了相关调用。注意使用关中段的方式保护内存的方法似乎仅适用于单核处理器。

下面是问题的回答：

### 2.1 请说明 ucore 是否做到给每个新 fork 的线程一个唯一的 id ？请说明你的分析和理由。

pid 的分配是在 `get_pid` 函数中完成的。在这个函数中采取了一种高效又可保证 pid 不重复的算法。每次分配之后，都会保存 `last_pid` `next_safe` 两个全局变量，分别表示上一个被分配的 pid 与大于上一个被分配的 pid 的最小的已使用的 pid。这样，只要 `last_pid` 加一小于 `next_safe` ，就可以迅速地得到一个新的 pid，而在其他情况，则需要重新维护 `last_pid` `next_safe` 的值，先寻找一个 `last_pid`，再计算对应的 `next_safe`。

## 练习3：阅读代码，理解 `proc_run` 函数和它调用的函数如何完成进程切换的。

`proc_run` 函数中，如果确实改变了进程，就会修改当前进程、修改栈顶指针（用于函数返回）、修改页表、切换上下文。这样，中断返回后就已经在新的进程中了。

下面是问题的回答：

### 3.1 在本实验的执行过程中，创建且运行了几个内核线程？

两个， `idle` 与 `init`。`idle` 为系统空闲进程，只会不断地把控制权让给其他线程，`init` 线程在本实验中仅用于打印字符串。

### 3.2 语句 `local_intr_save(intr_flag);....local_intr_restore(intr_flag);` 在这里有何作用？

暂时关闭中断，于是在单核处理器中不会在此处触发中断从而切换到其他线程，这样可以保护全局变量。