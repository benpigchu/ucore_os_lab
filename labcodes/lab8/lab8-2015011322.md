# Lab8 报告

## 知识点

虚拟文件系统、文件描述符、dentry 和 inode、inode 缓存、“打开的文件”结构、管道。除此之外还有 ucore 自己的文件系统架构以及其 Simple FS。

没有涉及信号、消息队列、共享内存等其他进程间通信机制。磁盘相关的细节（RAID、磁盘调度算法、磁盘缓存）以及一般的 IO 操作也没有涉及。

## 练习 0

`proc_struct` 新增的文件系统相关结构需要初始化。`do_fork` 时也需要额外复制。

## 练习 1：完成读文件操作的实现

这次的注释终于没有那么完整了，但是我们的实现依旧与参考答案基本一致。我们需要实现的部分是将文件中一个区间内的内容和内存缓存中的内容进行交换（读出或写回）。函数已经为我们把读写操作抽象为两个函数指针 `sfs_buf_op` 用于处理某个块的一部分和 `sfs_block_op` 用于处理连续的块，同时可以使用 `sfs_bmap_load_nolock` 查询文件与硬盘块的对应关系

我们所需要做的是把相应的区间切成若干块，然后逐块处理。如果区间的起点没有对齐，先处理第一个块的这一部分，如果这样就可以直接结束了就直接结束，接下来逐块处理中间完整的块，最后如果区间的终点也未对齐，把最后一块的这一部分处理一下。

注意尽管 `sfs_block_op` 可以一次处理多个块，但由于 `sfs_bmap_load_nolock` 只能转换一个块，所以我们还是一个一个块处理。

以下是问题的回答：

### 1.1 设计实现"UNIX 的 PIPE 机制"的概要设计方案

首先我们要有一类管道结构。

管道结构的初始化会创建两个对应的 inode（读侧与写侧），分配（环形）缓冲区，初始化读写等待状态。

对读侧读时，若缓冲区有数据，便将其部分移到用户空间，唤醒写侧，若还未读完就等待，否则若写侧被关闭则移动剩余数据并返回，若写侧未关闭则等待有写入或写侧被关闭。

对写侧写时，若读侧被关闭直接返回，若缓冲区有空间，便将其部分移到缓冲区，若还未写完就等待，唤醒读侧，否则等待有读入或读侧被关闭。

读侧和写侧关闭时唤醒对方。

可以利用类似信号量机制来实现读写协调。

最后，向用户空间提供系统调用建立管道并获取相应的 inode 对应的文件描述符。

## 练习 2：完成基于文件系统的执行程序机制的实现

只需实现 `load_icode` 函数。由于以往实验中已有 `load_icode` 函数存在，但功能略有不同，所以将其复制过来进行修改。主要的修改是将从内存中复制改为文件读取和添加 argv 的设置。读取文件可使用已有的 `load_icode_read` 函数实现。而 argv 的设置便略微复杂一些。

由于用户函数的入口 `initcode.S` 中的 `_start` 会将 栈顶的值作为 argc，同时将栈顶减 4 作为 argv 的位置，故只需将 argv 中的字符串内容载入栈，并将他们的位置作为 argv 放入栈，并将 argc 放在栈顶，最后重设用户 `esp` 位置即可。

这里与参考答案的实现尽管有细微不同，但是是一致的。

以下是问题的回答：

### 2.1 设计实现“UNIX 的硬链接和软链接机制”的概要设计方案

对于硬链接，我们需要增加 inode 的引用计数字段。创建时设置指针并增加引用计数，删除时减少引用计数，引用计数为零时再正式删除即可。

对于软链接，我们把它作为特殊的，存储了路径的文件即可。但是做路径查找等操作时需要对其做特殊处理。